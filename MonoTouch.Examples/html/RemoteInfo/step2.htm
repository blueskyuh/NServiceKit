<html class="tutorial">
<head>
	<title>MonoTouch Examples :: RemoteInfo</title>
    <link rel="stylesheet" type="text/css" href="../css/default.css" />
    <link rel="stylesheet" type="text/css" href="../css/remoteinfo.css" />
</head>
<body>
	<a id="title-img" href="default.htm"><img src="../img/MonoTouch-ServiceStack.png" alt="MonoTouch ServiceStack"></a>
	<h3 class="step">Step 2 - Calling the GetDirectoryInfo Web Service</h3>

	<div class="section">

	<h4>GetDirectoryInfo Web Service</h4>
	<p>
		The above solution contains the implementation of the <span class="ws">GetDirectoryInfo</span> web service.
		The <b class="file">GetDirectoryInfo.cs</b> class contains the contract of the service i.e. What it accepts (Request DTO) and
		what it returns (Response DTO). 
	</p>

	<img src="../img/GetDirectoryInfo-op.png" class="left-wtext">
	
	<p>
		Although not required, it is a good idea to keep the definition of your 'web services' separate from your implementation 
		as it will allow you to share this assembly with your .NET clients.
	</p>
	<p>
		As can be seen from the Example code, defining your web service definition is simply done with 
		<acronym title="Plain Old CSharp Objects">POCO</acronym> DataContract classes.
		ServiceStack doesn't impose any enforced structure or interfaces which means that you have complete control of the definition
		of your web service, including its XML namespaces.
	</p>
	<p>
		A convention that ServiceStack does use is that the name of your Response DTO should be: 
		<br />
		[Name of Request DTO] + 'Response'. Which in this case would be 'GetDirectoryInfoResponse'.
	</p>
	
	<p class="clear">
		For completeness I've included the other DataContract's used by this service below:
	</p>
	
	<div class="right-col">
	<p>
		So a pretty simple service, from the DTO's we can tell our <b class="ws">GetDirectoryInfo</b> Web Service:
	</p>
	<ul>
		<li>Accepts a 'ForPath' argument</li>
		<li>Returns a list of <b>DirectoryResult</b> and <b>FileResult</b> DTO's</li>
		<li>The <b>DirectoryResult</b> contains the Name and FileCount of a directory</li>
		<li>While the <b>FileResult</b> contains the Name, Extension, FileSize and whether its a Text file or not</li>
	</ul>
	<p>
		For lack of a better idea, the <b class="ws">GetDirectoryInfo</b> service actually sends back info about itself, 
		(i.e. It allows you view the entire file/directory structure of the RemoteInfo solution). You can of course change
		the root Directory it looks at in the Application .config file (i.e. Web.Config).
	</p>
	</div>

	<img src="../img/DirectoryResult-dto.png" class="left-wtext" />
	<img src="../img/FileResult-dto.png"  class="left-wtext" />
	
	<p class="clear">
		The only thing remaining to make this web service work is the actual implementation :) which I've included below:
	</p>
	<img src="../img/ws-handler.png" class="left-wtext" />
	<p>
		So there a couple of things going here. The first is to tell ServiceStack which Web Service we are implementing.
		This is done with the specifying the type of Request DTO in the <b class="attr">Port</b> Attribute.
	</p>
	<p>
		The next step is to tell ServiceStack what type of Web Service implementation this is by inheriting from the service 
		implementation interface of your choice. Nearly all times this will be <b class="interface">IService</b> as you'll
		want to deal with strongly-typed DTO's. If you prefer to deal with the XML Stream directly than you can inherit from
		IXmlService instead.
	</p>
	<p>
		The constructor for your handler should either be empty or containing members of providers you've registered in your 
		<b class="cs">AppHost.cs</b> file.
	</p>
	<p>
		The <b class="interface">IService</b> has one method which is <code>object Execute(IOperationContext)</code>
		The IOperationContext that gets passed in is also defined in the <b class="cs">AppHost.cs</b> and will contain
		the Request DTO and ApplicationContext singleton at a minimum. You can retrieve anything from the RequestContext
		including the Request DTO for this call using the method <code>context.Request.Get&lt;T&gt;();</code>
	</p>
	<p>
		The last thing on the TODO list is to return the an instance of the Web Services Response DTO, which in this case is
		an instance of <b class="cs">GetDirectoryInfoResponse</b>.
	</p>
	
	<p class="clear">
		That's all there is to it! If you start XSP again you can now call this Web Service via REST using the following url:
		<ul>
			<li>(XML): http://localhost:8080/Public/Xml/SyncReply/GetDirectoryInfo</li>
			<li>(JSON): http://localhost:8080/Public/Json/SyncReply/GetDirectoryInfo</li>
		</ul>
	</p>
	<p>
		Calling the REST service with arguments is done by adding Key/Value pairs to QueryString that the Web Service expects. 
		Since the Web Service displays information about itself you can view the contents of the directory where the
		handler is using the following url: 
	</p>
	<p>
		<a href="http://localhost:8080/Public/Xml/SyncReply/GetDirectoryInfo?ForPath=/Server/RemoteInfo.ServiceInterface">
			http://localhost:8080/Public/Xml/SyncReply/GetDirectoryInfo?ForPath=/Server/RemoteInfo.ServiceInterface
		</a>
	</p>
	<p>
		Assuming you have no problems, navigating to that url from a browser with a decent XML renderer 
		(for me thats Firefox on OSX) should give you:
	</p>	
	<img src="../img/ws-rest-qs.png" />

	<p>
		A REST-full Web Service, Cool!<br /> 
		Next step is to call the Web Service from inside a .NET application. 
		Before we attempt to call this service from MonoTouch, it is a good idea to test calling the Web Service from
		 a standard .NET Console Application as it will help you identify whether any errors are Web Service or MonoTouch related.
	</p>
	<p>
		The <b class="proj">RemoteInfo.Tests.ConsoleClient</b> does exactly this, it lets you call the
		<b class="ws">GetDirectoryInfo</b> Web Service with JSON or XML using either the XSP or Console Host. 
		The easiest way to get this running is to set <b class="proj">RemoteInfo.Tests.ConsoleClient</b> 
		as your 'Startup Project' and hit 'Debug', if all is good should expect to see:
	</p>
	<img src="../img/consoleclient-running.png" />
	
	<p>
		You can run the ConsoleClient with different arguments to change the Web Service Host 
		(i.e. Web Host or Console Host) or End Point (i.e. XML or JSON) you want to call.
		Regardless of the combination you use, the 'client code' to call and access the Response remains the same
		as can be seen onwards from <em>Line 58</em>.
	</p>
	
	</div>

	<div class="page-nav">
		<div class="previous">
			<a href="default.htm">Step 1 - Getting Started</a>
		</div>
		<div class="next">
			<a href="step3.htm">Step 3 - Calling the Web Service from MonoTouch</a>
		</div>
	</div>
	
</body>
</html>